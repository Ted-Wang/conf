
ctrl+x ctrl+e then ZZ   # send command to vim for editing, then ZZ exit vim, the command will be execute directly.
#- 如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。
    #- 那么，你可以按下 Alt-#(alt+shift+3) ，于是这个命令关就被加了一个#字符，于是就被注释掉了。

#* 如何在远程服务器运行一个本地脚本
	#- 无参数
		ssh user@server 'bash -s' < local.script.sh
	#- 有参数
		ssh user@server ARG1="arg1" ARG2="arg2" 'bash -s' < local_script.sh

cp file{,.bak}          # a shorten typing to backup a file
touch file_{a..z}.txt   # create a bunch of files
echo {10..20..2}        # generate a number list
#- combine several commands' output together
{ echo "I found all these PNGs:"; find . -iname "*.png"; echo "Within this bunch of files:"; ls; } > PNGs.txt

#- redirect script's output to a file combined with a timestamp. useful in crontab job.
myscript.sh 2> >( while read line; do echo "$(date): ${line}"; done > error.log ) 1>&2

alias wol='bash /d/ws/sync/conf/script/wol.sh'
alias wol='bash ~/prj/conf/script/wol.sh'

nohup command > executing.log 2>&1 &
alias simu='java -jar system-monitor.jar | tee -a sys-mon.log >/dev/null 2>&1 &'    # tee -a means append

echo "abc" | tee f1 f2      # 将前一个命令的输出，（在输出到 stdout 的）同时输出到 f1 和 f2 中。

watch -n 1 "df -m && du -h --max-depth=0 .m2"

curl -x 172.17.1.110:10809 google.com
curl -x socks5://172.17.1.110:10808 google.com
curl -LO url
curl -L -o fileName url

alt+.       # means the last argument of previous command, repeat to get other one before previous
!^/!*       # both stand for all arguments of previous command

ls | grep -v file.txt | xargs rm        # rm other files except file.txt in current folder

curl -X GET "http://192.168.50.101:10000/?pf=zn&contract=2012&value=8000"
curl -LO <url>

scp user@server:/path/to/remotefile.zip /Local/Target/Destination

echo `date +%H:%M:%S`,`my_script.sh` >> ~/cputemp/`date +%Y-%m-%d`.csv
sudo blkid | column -t

sed -E 's/regex/replacement/g' inputFile > outputFile   # search and replace based on lines, then output to a new file.
sed -i 's/abc/def/g' fileName   # use -i to modify origin file, than means outputFile is same as inputFile.
sed -i.bak 's/abc/def/g' file   # modify file, and backup file.
sed -i 's/word/d' fileName      # delete lines which contains 'word'

tail -f -n -1000 jboss.log      # -f, follow append data; -n line number; -1000, lines to be print.
cat -n jobss.log                # print file with line number
grep -n "" jboss.log            # same as above
dpkg -l | grep fcitx | wc -l    # count "fcitx" related packages

echo -n > file  # empty a file
ls -i file      # show inode
ls -d ~/*/      # list only directories
ls -l | grep "^d"   # same as upper
ls -p | grep -v /   # list only files
find * -maxdepth 0 -type f          # same as upper one
du -h --max-depth=0 ~/myfolder      # show size of myfolder
du -h --max-depth=0 --exclude=.git ~/ws     # show size of repo 'conf', without meta data.

### compress, decopress/uncompress
	tar -xvf jdk-8u5-linux-x64.tar.gz
	tar -cvf test.tar.gz file1 file2 folder/*
	tar -I zstd -xvf archive.tar.zst
	tar --zstd xvf archive.tar.zst
	unzip package.zip -d dest_folder		# must use -d specify the dest folder
	unzip -l file.zip						# list files

grep -irn "regex" ~/folder  # search all files in ~/folder for "regex". i, ignore case; r, recursive; n, line number & content.
grep -irl "regex" ~/folder ~/other/file # l, show file names with matches content; L, show file name without matches. 
grep -irl --include=ted.*rc "font" ~/   # search all my personal rc files, with font related conf, only show file name.

find common_conf/ linux_conf/ -name *ted*
find conf/ | grep -i ted
find ~/ -iname 'ted'        # find file whose name is exactly 'ted', but match the letters case-insensitively.
find ~/ -name 'ted' -type f # do not display directories, sockets, or other non-regular file types. 
find ~/ -name 'ws' --maxdepth 3 -type d # find directories named ws, limit subdirectory traversal to 2 levels beneath the specified directory.
find ~/ -group dev          # list files in ~/ whose owning group is 'dev'
find . -name \*log\* -cmin -30 -exec grep -nH 'OrderSattus in StateMachine is not correct' {} ';'

### CLI tips
#- move
- alt+f/b move foward/backward a word
- ctrl+a/e move to the start/end of line
- ctrl+left/right, home/end  works for some terminal

#- cut and paste
- ctrl+shift+- undo, ----其实是ctrl+_  ，没找到redo
- ctrl+k/u cut from cursor to the end/start of line
- alt+d/BS cut from cursor to the end/start of word
- ctrl+w cut from cursor to previous whitespace
- ctrl+y paste the last cut text
- alt+y loop through and paste previously cut text (must use it after ctrl+y)
- CTRL+t Swap the last two characters before the cursor.
- ESC+t Swap the last two words before the cursor.

#- OP on history
- ctrl+r then type term, to search over history, repeat ctrl+r to loop through matched results
- ctrl+r twice, search the last remembered search term
- ctrl+j end the search and keep the current matching histroy entry. ESC will be OK as well, but will got a beep
- ctrl+g cancel the search and restore original line
- Up/Down arrow keys，go through the history

### String Operation in shell script
str="a sample string"
echo ${#str}
echo ${str:2:9}
echo ${str:0-13:9}
echo ${str#*sam}        # get string right of "sam"
echo ${str##*\ }        # get string right of last " "
echo ${str%am*}         # get string left of "am"
echo ${str%%\ *}        # get string left of last " "

str5="${name}Script: ${url}index.html"  # concatenate strings

### add proxy for shell
export http_proxy=http://127.0.0.1:8118
export https_proxy=http://127.0.0.1:8118

[//]: # ( vim: set syntax=sh: )
